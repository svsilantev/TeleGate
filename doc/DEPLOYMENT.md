[[Менеджер Telegram сессий TeleGate]]


**DEPLOYMENT.md**

# Развертывание сервиса (Deployment Guide)

В этом разделе описано, как развернуть и запустить сервис управления Telegram-сессиями на вашем сервере или локальной машине. Предполагается, że вы уже имеете доступ к исходному коду проекта и необходимым привилегиям для установки софта на сервер.

## Установка зависимостей

1. **Установите Python 3.** Убедитесь, что у вас установлен Python версии 3.8+ (проект совместим с Python 3.10, 3.11 и выше).
    
2. **Создайте виртуальное окружение (опционально):** Рекомендуется использовать виртуальное окружение для установки зависимостей, чтобы изолировать их. Например:
    
    bash
    
    Копировать
    
    `python3 -m venv venv source venv/bin/activate   # для Linux/Mac venv\Scripts\activate      # для Windows`
    
3. **Установите необходимые пакеты Python:** В файле `requirements.txt` перечислены зависимости проекта (если такой файл прилагается). Выполните:
    
    bash
    
    Копировать
    
    `pip install -r requirements.txt`
    
    Если файла зависимостей нет, установите основные библиотеки вручную:
    
    bash
    
    Копировать
    
    `pip install fastapi uvicorn psycopg2-binary`
    
    - `fastapi` – фреймворк для API.
    - `uvicorn` – ASGI-сервер для запуска приложения (используется в разработке).
    - `psycopg2-binary` – библиотека для работы с PostgreSQL. Используем вариант `-binary` для упрощённой установки.  
        _(Также может понадобиться `requests` для работы клиентской части или тестирования, но для самого сервера это не обязательно.)_
4. **Дополнительные зависимости:** Убедитесь, что на системе установлен PostgreSQL (см. ниже). Также, если вы планируете использовать Gunicorn для продакшена, установите его:
    
    bash
    
    Копировать
    
    `pip install gunicorn`
    
    Gunicorn понадобится для устойчивого запуска приложения на сервере.
    

## Настройка базы данных PostgreSQL

Сервис использует PostgreSQL для хранения данных о сессиях. Следующие шаги предполагают, что у вас уже установлен PostgreSQL сервер:

1. **Создайте базу данных и пользователя:**
    
    - Имя базы данных по умолчанию ожидается `telethon_db` (можете выбрать другое, но не забудьте скорректировать настройки).
    - Создайте пользователя (например, `session_user`) и задайте ему пароль. Также дайте этому пользователю права на созданную базу.  
        Пример (в PostgreSQL console):
    
    sql
    
    Копировать
    
    `CREATE DATABASE telethon_db; CREATE USER session_user WITH PASSWORD 'your_password'; GRANT ALL PRIVILEGES ON DATABASE telethon_db TO session_user;`
    
    Вы можете использовать и существующую базу/пользователя, главное — убедиться, что учётные данные верны.
    
2. **Сконфигурируйте подключение в проекте:** В файле `db.py` заданы параметры подключения:
    
    python
    
    Копировать
    
    `DB_CONFIG = {     "host": "localhost",     "port": "5432",     "database": "telethon_db",     "user": "ssilantev",     "password": "u2997988U" }`
    
    Отредактируйте эти значения под свои настройки: `host` (если база на отдельном сервере, укажите его адрес; для локальной установки оставьте `"localhost"`), `port` (стандартный 5432, либо ваш), `database` (имя базы), `user` и `password` (учётные данные, созданные на шаге 1).
    
    > **Примечание:** В демонстрационных целях в коде указаны примерные данные. В боевой среде не следует хранить пароль открытым текстом. Вы можете улучшить конфигурацию, например, брать пароль из переменных окружения или файла конфигурации.
    
3. **Инициализируйте структуру базы:** В проекте имеется скрипт `init_db.py`, который создаёт необходимую таблицу (если она ещё не создана). Запустите его:
    
    bash
    
    Копировать
    
    `python init_db.py`
    
    Он подключится к базе с указанными в `DB_CONFIG` параметрами и создаст таблицу `sessions`. Если всё прошло успешно, вы увидите сообщение `✅ База данных инициализирована. Таблица sessions проверена.`.  
    Таблица `sessions` содержит колонки:
    
    - `id SERIAL PRIMARY KEY` – уникальный идентификатор сессии.
    - `session_name TEXT UNIQUE NOT NULL` – имя сессии (уникально, обычно соответствует имени файла .session).
    - `in_use BOOLEAN` – флаг занятости (TRUE, если сессия выдана и в использовании).
    - `last_used TIMESTAMP` – время последнего использования (для отслеживания зависших сессий).
    - `in_floodwait BOOLEAN` – флаг состояния Flood Wait (TRUE, если сессия временно "заморожена" из-за ограничения Telegram).
    - `floodwait_until TIMESTAMP` – время до которого сессия находится в состоянии Flood Wait (может быть NULL, если ограничения нет).
    - Поля для прокси (`proxy_host`, `proxy_port`, `proxy_type`, `proxy_login`, `proxy_password`) – если ваши сессии используют прокси-сервер, эти данные могут храниться в базе (в текущей реализации новые сессии получают прокси по умолчанию, указанный в коде).
    
    Убедитесь, что таблица создана правильно (можно проверить напрямую в базе, выполнив `SELECT * FROM sessions;`, она должна быть пустой или содержать данные, если вы ранее запускали синхронизацию).
    

## Запуск сервера (режим разработки)

После настройки среды и базы данных можно запустить сервис. Убедитесь, что на этапе конфигурации вы добавили необходимые API-ключи (по умолчанию в `main.py` задан список `ALLOWED_API_KEYS` с некоторыми значениями – замените или дополните их своими ключами для доступа). Для запуска используйте Uvicorn:

bash

Копировать

`uvicorn main:app --host 0.0.0.0 --port 8000 --reload`

Пояснения к команде:

- `main:app` – указывает Uvicorn, где искать объект приложения. В нашем случае это файл `main.py` и созданный в нём экземпляр FastAPI `app`.
- `--host 0.0.0.0` – позволяет принимать подключения со всех сетевых интерфейсов (если вы тестируете локально, можете опустить или указать `--host 127.0.0.1`).
- `--port 8000` – порт, на котором запустится сервис (можете изменить при необходимости).
- `--reload` – включает автоматическую перезагрузку при изменении кода (удобно в разработке, не используйте в продакшене).

После запуска вы должны увидеть в консоли логи запуска Uvicorn. Сервис будет доступен по указанному адресу. Вы можете проверить работу, выполнив простой запрос к эндпоинту статуса. Например, через `curl`:

bash

Копировать

`curl -H "X-API-Key: <Ваш ключ>" http://localhost:8000/status`

При корректной настройке должен вернуться JSON с статистикой (даже если пока все значения по нулям). Если получаете ошибку 401/403, проверьте API-ключ. Если сервис не отвечает, убедитесь, что Uvicorn запущен без ошибок (в консоли должны отсутствовать traceback-и).

Также по адресу `http://localhost:8000/docs` доступна автоматическая документация Swagger (OpenAPI) от FastAPI. Учтите, что для выполнения запросов через веб-интерфейс документации потребуется ввести API-ключ (кнопка "Authorize" в Swagger UI).

## Продакшн: настройка Gunicorn + Uvicorn (Systemd)

Для развёртывания в продакшене рекомендуется использовать Gunicorn в связке с Uvicorn Worker. Gunicorn будет управлять процессами, обеспечивая надёжность и возможность запуска в виде службы, а Uvicorn будет непосредственно запускать ASGI-приложение.

**Шаг 1: Установка Gunicorn (если не сделано):**

bash

Копировать

`pip install gunicorn`

**Шаг 2: Тестовый запуск Gunicorn:**  
Протестируйте запуск приложения через Gunicorn из командной строки:

bash

Копировать

`gunicorn main:app -k uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000`

Параметры:

- `-k uvicorn.workers.UvicornWorker` – используем рабочий процесс Uvicorn для Gunicorn.
- `--bind 0.0.0.0:8000` – адрес и порт. Можно изменить порт при необходимости или привязать к UNIX-сокету.
- По умолчанию Gunicorn запустит несколько воркеров (количество зависит от числа ядер CPU). Вы можете настроить число рабочих процессов опцией `-w`. Для начала оставим по умолчанию или укажем `-w 2` (например, 2 воркера).

Убедитесь, что сервис запустился без ошибок. Остановите Gunicorn (Ctrl+C), чтобы перейти к следующему шагу.

**Шаг 3: Создание systemd сервиса:**  
Настройте systemd, чтобы запускать сервис как демона при старте системы. Создайте файл службы, например `/etc/systemd/system/telegram-session-manager.service` со следующим содержимым:

ini

Копировать

`[Unit] Description=Telegram Session Manager API service After=network.target postgresql.service  [Service] User=your_user Group=your_user_group WorkingDirectory=/path/to/project Environment="PYTHONUNBUFFERED=1" ExecStart=/path/to/venv/bin/gunicorn main:app -k uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000 -w 4 Restart=always RestartSec=5  [Install] WantedBy=multi-user.target`

Где необходимо заменить:

- `your_user` на имя пользователя, от которого должен запускаться сервис (лучше создать отдельного пользователя для приложения или использовать существующего непривилегированного пользователя, не root).
- `your_user_group` на группу этого пользователя.
- `WorkingDirectory` – на путь до директории с вашим проектом (где находится `main.py`).
- Путь в `ExecStart` – на путь до вашего исполняемого Gunicorn (если вы использовали виртуальное окружение, то это путь до gunicorn внутри venv, обычно как показано). Также можно добавить необходимые параметры (порт, воркеры и пр.). Здесь выставлено 4 воркера (`-w 4`), скорректируйте по ресурсам вашего сервера.
- Опция `Environment` установлена для примера (отключает буферизацию вывода). Вы можете добавить туда переменные окружения, если они вам нужны для конфигурации (например, переменные для пароля БД или API-ключей, если бы сервис их читал из окружения).

Сохраните файл и убедитесь, что права доступа позволяют systemd читать его (обычно достаточно прав `644`).

**Шаг 4: Запуск и автостарт службы:**  
После создания файла выполните команду:

bash

Копировать

`sudo systemctl daemon-reload`

чтобы systemd прочитал новую конфигурацию. Затем запустите сервис:

bash

Копировать

`sudo systemctl start telegram-session-manager`

и при необходимости посмотрите его лог:

bash

Копировать

`sudo journalctl -u telegram-session-manager -f`

Если всё запущено корректно, вы увидите в логе сообщения об инициализации приложения (например, запуск фоновых задач). Сервис должен начать слушать указанный порт. Проверьте доступность, сделав запрос к `/status` как ранее.

Чтобы сервис автоматически запускался при перезагрузке сервера, выполните:

bash

Копировать

`sudo systemctl enable telegram-session-manager`

Теперь ваш API-сервис будет постоянно работать в фоне. Убедитесь, что настроены **брандмауэр/правила доступа** к порту (если нужно, откройте порт 8000 или используйте прокси-сервер/балансировщик). Также следите за логами (`journalctl` или настроить ротацию логов). Логи приложения по умолчанию пишутся в файл `session_manager.log` в рабочей директории – убедитесь, что у пользователя сервиса достаточно прав на запись в неё.

## Дополнительные замечания

- **API-ключи в продакшене:** текущая реализация ожидает ключи в списке `ALLOWED_API_KEYS` внутри приложения. Для более гибкой настройки в продакшене вы можете реализовать хранение ключей в базе данных или файле конфигурации. Альтернативно, временно отредактируйте список в `main.py`, добавив требуемые ключи, перед тем как запускать сервис. Не раскрывайте эти ключи публично.
- **Обновление сессий:** при добавлении новых Telegram-сессий (файлов) на диск, вы можете либо перезапустить сервис, либо вызвать `/sync` (через `curl` или автоматически) для регистрации их в базе. В продакшене автоматическая фоновая задача будет проверять изменения каждый час.
- **Резервное копирование данных:** база данных содержит все сессии и их текущее состояние. Рекомендуется периодически делать бекап таблицы `sessions` или всей базы `telethon_db` во избежание потери данных о пуле (особенно если вручную помечаете сессии как инвалидированные). Сами файлы сессий на диске также важно сохранять.

Следуя этим инструкциям, вы сможете развернуть сервис управления Telegram-сессиями и обеспечить его стабильную работу как в режиме разработки, так и на боевом сервере.