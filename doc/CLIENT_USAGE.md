[[Менеджер Telegram сессий TeleGate]]



**CLIENT_USAGE.md**

# Руководство по использованию клиентской библиотеки

Для удобства интеграции, проект включает клиентскую библиотеку на Python, которая упрощает работу с API. С её помощью можно вызывать методы сервиса, не заботясь о формировании HTTP-запросов вручную. Библиотека также предоставляет удобные методы для типичных операций (получение/освобождение сессии) и автоматически обрабатывает ситуацию, когда нет свободных сессий (в режиме ожидания).

## Установка библиотеки

Чтобы установить клиентскую библиотеку, используйте `pip`. Если она опубликована в PyPI, вы можете установить её командой (имя пакета указано условно):

bash

Копировать

`pip install telegram-session-manager-client`

Если библиотека ещё не опубликована, ее можно установить прямо из исходного кода. Например, клонируйте репозиторий с проектом и выполните установку:

bash

Копировать

`git clone https://github.com/your-repo/telegram-session-manager.git cd telegram-session-manager pip install .`

После установки в вашей среде должен быть доступен модуль с клиентом (например, `telegram_session_manager` или аналогично, в зависимости от реального названия пакета).

> **Примечание:** В проекте также присутствует файл `client.py`. Вы можете напрямую использовать его, поместив в свой проект, однако рекомендован способ установки через `pip`, чтобы получать обновления и зависимости автоматически.

## Создание экземпляра клиента

После установки библиотеки импортируйте класс клиента и создайте его экземпляр, указав адрес API и ваш API-ключ:

python

Копировать

`from telegram_session_manager import TelegramSessionManagerClient  # Инициализация клиента client = TelegramSessionManagerClient(     base_url="http://localhost:8000",   # URL сервиса (без завершающего слеша)     api_key="ВАШ_API-КЛЮЧ",            # ваш API-ключ для доступа     auto_wait=True                     # автоматическое ожидание освобождения сессии (включено по умолчанию) )`

Параметры при инициализации:

- **base_url** – базовый URL запущенного сервиса (например, `http://localhost:8000` или адрес вашего сервера). Важно указывать без завершающего `/`.
- **api_key** – строка с API-ключом, выданным для доступа к сервису. Все запросы клиента будут использовать этот ключ для авторизации.
- **auto_wait** – логический флаг (по умолчанию `True`). Определяет поведение метода получения сессии, если на данный момент нет свободных сессий.
    - Если `auto_wait=True`, метод `get_session()` **автоматически подождёт** требуемое время и повторит попытку получения сессии, если сервис вернёт ответ о отсутствии сессий с указанием времени ожидания. Процесс ожидания происходит внутри клиента, и вызов вернётся только когда сессия будет получена (либо когда станет понятно, что ждать бессмысленно).
    - Если `auto_wait=False`, метод `get_session()` не будет ждать. При отсутствии свободных сессий он сразу выбросит исключение `NoSessionAvailable`. Этот вариант удобен, если вы хотите самостоятельно обрабатывать ожидание (например, сделать свою логику повторных попыток или уведомить пользователя).

## Основные методы клиента

Класс `TelegramSessionManagerClient` предоставляет следующие основные методы для работы с API:

### `get_session()`

Запрашивает у API свободную сессию. Вызов этого метода соответствует обращению к эндпоинту `/session`. Поведение зависит от наличия свободных сессий и параметра `auto_wait`:

- Если есть свободная сессия, метод возвращает словарь с данными сессии: `{"session_id": ..., "session_name": ...}`. Эти значения можно использовать в вашем приложении (например, `session_name` может служить для инициализации Telegram-клиента Telethon).
- Если свободных сессий нет:
    - При `auto_wait=True` – метод выведет сообщение в консоль о том, что свободных сессий нет и сколько секунд ожидания, затем приостанавливает выполнение на указанный промежуток времени. По истечении времени он **автоматически повторит запрос** `get_session()`. Это будет происходить до тех пор, пока либо не будет получена сессия, либо пока сервис не перестанет указывать время ожидания. Если время ожидания не указано (`next_release_in` = `null`), клиент выбросит исключение (чтобы избежать бесконечного ожидания неизвестно чего).
    - При `auto_wait=False` – метод **сразу** выбросит исключение `NoSessionAvailable`, не делая повторных попыток. Исключение содержит информацию о количестве заблокированных сессий и времени до разблокировки ближайшей (если известно).

**Возвращаемое значение:** при успешном получении – словарь с ключами `session_id` и `session_name`. Если используется `auto_wait=False` и сессия недоступна, бросается исключение `NoSessionAvailable`.

**Пример использования:**

python

Копировать

`# Попытка получить сессию (режим auto_wait=False для демонстрации обработки ошибки) client = TelegramSessionManagerClient(base_url="http://localhost:8000", api_key="MYKEY", auto_wait=False) try:     session = client.get_session()     print(f"Получена сессия ID={session['session_id']}, имя={session['session_name']}") except NoSessionAvailable as e:     print(f"Нет свободной сессии. В Flood Wait: {e.waiting_count}. Ближайшая разблокировка через {e.next_release_in} сек.")     # Здесь можно реализовать логику ожидания или повторного запроса`

В примере выше, если нет доступных сессий, мы ловим исключение `NoSessionAvailable` и выводим информацию: сколько сессий в Flood Wait и через сколько секунд одна освободится. В реальном сценарии можно, например, подождать `e.next_release_in` секунд и попробовать снова получить сессию.

Если бы `auto_wait=True`, то вызов `client.get_session()` сам бы ждал необходимое время и вернул сессию, когда она появится, либо выбросил исключение, если ожидание бессмысленно.

### `release_session(session_id)`

Отправляет запрос к API для освобождения сессии с заданным идентификатором. Аналог эндпоинта `/release`. Обычно вызывается в блоке `finally` или при завершении работы с Telegram-аккаунтом, чтобы гарантировать освобождение ресурса.

- `session_id` (int) – ID сессии, полученной ранее через `get_session()`, которую нужно вернуть в пул.

Возвращает `True` в случае успешного выполнения (на стороне сервера это соответствует ответу со статусом "released"). Если `session_id` некорректен или сессия уже свободна, метод все равно вернёт успех (исключения не генерируются), так как сервер не считает это ошибкой.

**Пример использования:**

python

Копировать

`session = client.get_session() try:     # ... работа с Telegram сессией ...     pass finally:     client.release_session(session["session_id"])     print("Сессия освобождена")`

В этом примере мы гарантируем вызов `release_session` в блоке `finally`, чтобы сессия освободилась даже если в процессе работы произошла ошибка.

### `get_status()`

Запрашивает у сервера текущую статистику пула сессий. Обращается к эндпоинту `/status`. Этот метод не требует параметров.

Возвращает словарь с теми же полями, которые описаны в разделе API для `/status`: `total`, `free`, `in_use`, `in_floodwait`, `next_available`.

**Пример использования:**

python

Копировать

`stats = client.get_status() print(f"Всего сессий: {stats['total']}") print(f"Свободно: {stats['free']}, Занято: {stats['in_use']}, В ожидании: {stats['in_floodwait']}") if stats.get("next_available"):     print(f"Ближайшая сессия освободится: {stats['next_available']}")`

Этот код получит статистику и выведет её в понятном виде. Поле `next_available` (если не `None`) содержит отметку времени в формате строки.

## Пример интеграции клиента в проект

Ниже приведён полный пример использования клиентской библиотеки в типичном сценарии:

python

Копировать

`from telegram_session_manager import TelegramSessionManagerClient, NoSessionAvailable  client = TelegramSessionManagerClient(base_url="http://localhost:8000", api_key="MY_API_KEY")  try:     # Запрашиваем сессию из пула     session = client.get_session()     session_id = session["session_id"]     session_name = session["session_name"]     print(f"✅ Получена сессия #{session_id} с именем '{session_name}'")          # Здесь можно инициализировать Telegram-клиент (например, Telethon) используя файл с именем session_name     # и выполнить необходимые действия с аккаунтом.     # ...      finally:     # В любом случае (при успехе или исключении выше) освобождаем сессию     client.release_session(session_id)     print(f"✅ Сессия #{session_id} возвращена в пул")`

В этом примере:

1. Создаётся клиент `TelegramSessionManagerClient` с указанием URL сервиса и API-ключа.
2. Пытаемся получить свободную сессию. Если `auto_wait=True` (по умолчанию), клиент может подождать, пока сессия не появится. Если `auto_wait=False`, имеет смысл обернуть вызов в `try/except` и обработать `NoSessionAvailable`.
3. При успешном получении мы получаем `session_id` и `session_name`. Далее, зная имя файла сессии, можно запустить Telegram-клиент (Telethon/Pyrogram) и выполнить необходимые действия от лица этого аккаунта.
4. В блоке `finally` освобождаем сессию вызовом `release_session`, чтобы даже в случае ошибки или исключения сессия не осталась занята.

Таким образом, использование клиентской библиотеки сводит работу с API к нескольким простым методам, что облегчает интеграцию сервиса в ваши Python-проекты.]]