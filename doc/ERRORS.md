[[Менеджер Telegram сессий TeleGate]]


**ERRORS.md**

# Ошибки API и обработка исключений

Этот раздел описывает возможные ошибки, которые может возвращать API сервиса управления Telegram-сессиями, и способы их обработки. Ошибки могут возникать как при неправильном использовании (например, не указан API-ключ), так и при штатных ситуациях, таких как отсутствие свободных сессий.

## Основные коды ошибок и их значение

- **401 Unauthorized** – Отсутствует API-ключ. Сервис не получил заголовок `X-API-Key` в запросе. Необходимо включить действительный API-ключ в каждый запрос.
- **403 Forbidden** – Неверный API-ключ. В заголовке `X-API-Key` указан ключ, которого нет в списке разрешённых. Убедитесь, что используете правильный ключ, выданный для этого сервиса.
- **404 Not Found** – Запрашиваемый эндпоинт не существует. Проверьте URL запроса. Этот код также может возвращаться, если используется неправильный HTTP-метод для существующего маршрута.
- **422 Unprocessable Entity** – Неправильные параметры запроса. Обычно возникает, если не передан обязательный параметр или он имеет некорректный формат. Например, вызов `/release` или `/invalidate` без параметра `session_id` приведёт к автоматической ошибке валидации. Ответ в этом случае будет содержать детали: какие поля отсутствуют или неверны.
- **503 Service Unavailable** – Нет доступных сессий. Этот код возвращается методом `/session`, если в пуле нет ни одной свободной сессии (все заняты или временно заблокированы). В отличие от других ошибок, **503 код используется для штатной ситуации отсутствия ресурса**. Ответ сопровождается подробностями в поле `detail` (см. пример в документации эндпоинта `/session`). Клиентам следует обрабатывать эту ситуацию особым образом (см. ниже).
- **500 Internal Server Error** – Внутренняя ошибка сервера. Например, сбой при обращении к базе данных, непредвиденное исключение и т.п. Такие ошибки означают проблему на стороне сервиса. При их возникновении можно посмотреть логи сервера для диагностики. Клиенту в случае 500 стоит повторить попытку позже или уведомить обслуживающего разработчика.

Помимо этих, сервис может возвращать стандартные коды HTTP в соответствующих ситуациях (например, 405 Method Not Allowed при неправильном методе). Однако перечисленные выше – основные, с которыми сталкиваются клиенты.

## Обработка ситуации с отсутствием свободных сессий (код 503)

Самый специфичный случай – ошибка **503 Service Unavailable** при запросе сессии. Она означает, что сейчас сервис не может выдать ни одной сессии. Вместо простой ошибки, ответ содержит полезную информацию: сколько сессий находятся в режиме ожидания (_Flood Wait_) и сколько секунд до освобождения ближайшей.

**Как поступать клиенту, если получен 503 (no_free_session):**

- **Используя прямые HTTP-запросы:** Если вы не применяете нашу клиентскую библиотеку и делаете запросы напрямую, ваш код должен проверить код ответа. При получении 503 можно извлечь из ответа JSON поле `detail` и получить `next_release_in`. Если это значение не `null`, имеет смысл подождать указанное число секунд и затем повторить запрос `/session`. Если `next_release_in` равно `null`, это означает, что неизвестно когда появятся сессии (все текущие сессии недоступны на неопределённое время, например, инвалидированы). В таком случае можно либо реализовать экспоненциальную повторную попытку с увеличением интервала, либо уведомить администратора о проблеме.
    
- **Используя клиентскую библиотеку:** Библиотека `TelegramSessionManagerClient` как раз предназначена упростить эту логику. Если вы создали клиента с параметром `auto_wait=True`, то при вызове `get_session()` она сама обработает 503 ошибку: выведет сообщение о ожидании и задержит выполнение на требуемое время, после чего попробует снова. Вам не нужно специально писать код обработки – просто вызовите `get_session()` и он вернёт сессию, когда она станет доступна. Если же у клиента `auto_wait=False`, то метод бросит исключение `NoSessionAvailable`. В таком случае вы можете поймать это исключение и получить из него информацию: `e.waiting_count` (сколько сессий в Flood Wait) и `e.next_release_in` (сколько секунд до освобождения).
    

**Пример обработки ошибки 503 с использованием клиента (auto_wait=False):**

python

Копировать

`client = TelegramSessionManagerClient(base_url="http://localhost:8000", api_key="MYKEY", auto_wait=False) try:     session = client.get_session() except NoSessionAvailable as e:     print(f"Свободных сессий нет. В ожидании: {e.waiting_count} сессий.")     if e.next_release_in:         print(f"Ожидание {e.next_release_in} секунд до следующей попытки...")         time.sleep(e.next_release_in)         # После ожидания пробуем снова         session = client.get_session()     else:         print("Время разблокировки сессий неизвестно. Попробуйте позже или проверьте состояние сервиса.")`

В этом примере мы вручную ждем указанное время и повторно вызываем `get_session()`. На практике, при `auto_wait=True` эта логика выполняется внутри клиента автоматически.

## Обработка других ошибок

**401/403 (проблемы с API-ключом):** Такие ошибки говорят об ошибке аутентификации. Убедитесь, что передаёте заголовок `X-API-Key` во всех запросах. Если ключ указан, но вы получаете 403, проверьте правильность его значения и наличие в списке разрешённых. В коде клиента эти ошибки будут выбрасывать исключение при вызове `response.raise_for_status()`. Например, `requests` библиотека выбросит `requests.HTTPError`. Вы можете отловить её или, зная причину, сразу исправить ключ. Обычно 401/403 обрабатываются на уровне настройки – корректный ключ прописывается перед запуском и дальше эти ошибки не возникают.

**422 (ошибка в параметрах):** Чтобы избежать таких ошибок, всегда передавайте требуемые параметры. В нашем API все методы, кроме `/release` и `/invalidate`, не требуют дополнительных параметров (только API-ключ). Для `/release` и `/invalidate` нужно передавать `session_id`. Используя клиентскую библиотеку, вы защищены от 422, так как методы `release_session(session_id)` и `get_session()` всегда формируют корректные запросы. Если же вы делаете запрос напрямую и забыли параметр, необходимо исправить код. Обработка 422 обычно сводится к логированию: сервер в ответе укажет, что именно не так (например, отсутствует параметр `session_id`).

**500 (внутренняя ошибка):** Это нестандартная ситуация, которая не должна происходить при правильной работе сервиса. Тем не менее, на стороне клиента стоит иметь обработку исключений на случай, если сервер вернул неожидаемый код (500 или др.). Например, обернуть основной код взаимодействия в блок `try/except` и в случае исключения уведомить пользователя: _"Сервис временно недоступен, попробуйте позже."_ или записать ошибку в лог для дальнейшего разбора. В идеале, если 500 ошибки повторяются, следует проанализировать логи сервера и устранить причину.

Подводя итог, **большинство ошибок можно предотвратить правильным использованием API-ключа и параметров**. Ситуация же отсутствия сессий (503) не является ошибкой в прямом смысле, а сигнализирует, что нужно подождать – и наш клиент, и ваш код могут это учесть и действовать соответственно.