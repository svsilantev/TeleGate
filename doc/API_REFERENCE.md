[[Менеджер Telegram сессий TeleGate]]



**API_REFERENCE.md**

# Справочник API

Ниже перечислены все доступные маршруты (эндпоинты) API и подробности их использования. Все вызовы требуют авторизации через API-ключ: каждый запрос должен содержать заголовок `X-API-Key` с действительным ключом. Без этого ключа сервис вернёт ошибку **401 Unauthorized**, а при неверном ключе – **403 Forbidden** (см. раздел Ошибки для подробностей).

## Обзор эндпоинтов

|Метод|Маршрут|Описание|
|---|---|---|
|GET|`/status`|Получить текущий статус пула сессий (статистика).|
|GET|`/session`|Запросить свободную сессию из пула.|
|POST|`/release`|Освободить ранее полученную сессию (вернуть в пул).|
|POST|`/invalidate`|Инвалидировать сессию (исключить из выдачи до разблокировки).|
|POST|`/sync`|Синхронизировать базу с файлами сессий на диске.|

Ниже приведено подробное описание каждого маршрута: какие параметры принимает, что возвращает и какие коды ответа может выдавать.

## GET `/status` – Статус пула сессий

**Описание:** Возвращает агрегированную статистику по всем Telegram-сессиям в пуле. Этот эндпоинт полезен для мониторинга и понимания текущего состояния сервиса. В ответе содержатся следующие поля:

- `total` – общее количество зарегистрированных сессий в пуле.
- `free` – число свободных сессий (которые сейчас не заняты и не заблокированы ожиданием).
- `in_use` – число сессий, которые в данный момент выданы и находятся в использовании.
- `in_floodwait` – количество сессий, которые временно недоступны из-за ограничения _Flood Wait_ (Telegram временно запретил действия с них).
- `next_available` – время (таймстамп), когда какая-либо из заблокированных сессий выйдет из состояния _Flood Wait_ и станет доступной. Формат времени – `YYYY-MM-DD HH:MM:SS` в UTC. Если все сессии свободны или ни одна не заблокирована, значение может быть `null`.

**Пример запроса (cURL):**

bash

Копировать

`curl -X GET "http://localhost:8000/status" -H "X-API-Key: <Ваш API-ключ>"`

**Пример ответа (JSON):**

json

Копировать

`{     "total": 10,     "free": 7,     "in_use": 2,     "in_floodwait": 1,     "next_available": "2025-03-01 18:30:00" }`

В данном примере общее число сессий – 10. Из них 7 свободны, 2 заняты, 1 находится в состоянии ожидания (Flood Wait), и ближайшая разблокировка произойдёт в указанное время.

**Возможные коды ответа:**

- **200 OK** – запрос выполнен успешно, возвращена статистика (как в примере выше).
- **401 Unauthorized** – в запросе отсутствует заголовок API-ключа.
- **403 Forbidden** – указанный API-ключ недействителен.

## GET `/session` – Получить свободную сессию

**Описание:** Запрашивает выдачу свободной Telegram-сессии. Если в пуле имеется хотя бы одна не занятая и не заблокированная (без _Flood Wait_) сессия, сервис помечает её как занятую и возвращает клиенту. Если свободных сессий **нет**, сервис **не** будет блокировать запрос, а сразу вернёт информацию об отсутствии доступных сессий (специальная ошибка 503 с деталями).

Этот метод не требует тела запроса и не принимает параметров (кроме заголовка `X-API-Key` для авторизации).

**Пример запроса (cURL):**

bash

Копировать

`curl -X GET "http://localhost:8000/session" -H "X-API-Key: <Ваш API-ключ>"`

**Пример успешного ответа (JSON):**

json

Копировать

`{     "session_id": 42,     "session_name": "session42" }`

При успешной выдаче возвращается JSON с идентификатором сессии (`session_id`) и именем сессии (`session_name`). Имя сессии обычно соответствует имени файла сессии на диске (без расширения `.session`). Клиент может использовать эти данные, чтобы, например, подключиться к Telegram через соответствующий файл сессии.

Если свободных сессий нет, сервис возвращает ошибку **503 Service Unavailable**. В теле ответа будет JSON с детальной информацией:

**Пример ответа при отсутствии сессий (JSON):**

json

Копировать

`{     "detail": {         "error": "no_free_session",         "in_floodwait": 3,         "next_release_in": 3600     } }`

Поле `detail` содержит объект с деталями:

- `"error": "no_free_session"` – код ошибки, указывающий, что свободных сессий нет.
- `in_floodwait` – количество сессий, находящихся сейчас в состоянии Flood Wait (все они временно недоступны). В примере их 3.
- `next_release_in` – через сколько секунд _примерно_ освободится ближайшая из сессий (то есть выйдет из Flood Wait). В примере значение `3600` означает, что через час одна из заблокированных сессий станет доступна. Если значение `null`, это значит сервис не знает времени разблокировки (например, все сессии отсутствуют или помечены на неопределённо долгое ожидание).

Клиент может использовать эти данные, чтобы решить, ждать ли освобождения (см. раздел Ошибки о том, как обрабатывать эту ситуацию, и функциональность авто-ожидания в клиентской библиотеке).

**Возможные коды ответа:**

- **200 OK** – найдена свободная сессия, возвращены её данные (пример выше).
- **503 Service Unavailable** – свободных сессий нет (см. пример детального ответа выше). Клиенту придётся подождать или обработать эту ситуацию.
- **401 Unauthorized** – не указан API-ключ.
- **403 Forbidden** – API-ключ недействителен.

## POST `/release` – Освободить сессию

**Описание:** Возвращает ранее выданную сессию обратно в пул, помечая её как свободную. Этот метод **обязательно следует вызывать** после того, как вы завершили работу с полученной через `/session` сессией. Если не вызвать `/release`, сессия останется помеченной как занятая, и другие не смогут её получить (однако через некоторое время сервис автоматически освободит "зависшую" сессию благодаря фоновому процессу, чтобы избежать вечной блокировки).

**Параметры:** требуется один обязательный параметр `session_id` (целое число) – идентификатор сессии, которую нужно освободить. Этот параметр передаётся в query-параметрах URL или в теле запроса (например, как form data). **Важно:** `session_id` должен соответствовать ранее полученной сессии. Также необходимо передать заголовок `X-API-Key` для авторизации.

**Пример запроса (cURL):**

bash

Копировать

`curl -X POST "http://localhost:8000/release?session_id=42" -H "X-API-Key: <Ваш API-ключ>"`

_(в данном примере освобождается сессия с идентификатором 42)_

**Пример ответа (JSON):**

json

Копировать

`{     "status": "released",     "session_id": 42 }`

Если указанный `session_id` валиден, сервис вернёт подтверждение `"status": "released"`. Даже если сессия уже была свободна или несуществующая (например, передан неверный ID), ответ всё равно будет успешным – запрос **идемпотентен**. Это сделано для удобства: повторный вызов освобождения или освобождение несуществующей сессии не приведёт к ошибке на стороне сервиса (но в логах может быть зафиксировано отсутствие такой сессии).

**Возможные коды ответа:**

- **200 OK** – сессия успешно помечена свободной (или уже была свободна).
- **401 Unauthorized** – не указан или отсутствует API-ключ.
- **403 Forbidden** – недействительный API-ключ.
- **422 Unprocessable Entity** – отсутствует обязательный параметр `session_id` или он имеет некорректный формат (например, передан нецелочисленный ID). В этом случае в ответе будет описание ошибки валидации.

## POST `/invalidate` – Инвалидировать сессию

**Описание:** Исключает указанную сессию из пула доступных. По сути, помечает сессию как **недоступную до дальнейшего ручного вмешательства**. Этот метод стоит вызывать, например, если при работе с Telegram выяснилось, что аккаунт привязан к сессии, попал под продолжительный бан или требует дополнительной проверки, и вы хотите временно (или навсегда) убрать его из автоматической выдачи. Реализация этого эндпоинта устанавливает для данной сессии флаг Flood Wait на очень большой срок (например, до года 2099), что эффективно предотвращает её выдачу.

**Параметры:** требуется `session_id` (int) – идентификатор сессии, которую нужно инвалидировать. Передаётся как query-параметр или в теле запроса аналогично `/release`. Не забудьте указать заголовок `X-API-Key` для авторизации.

**Пример запроса (cURL):**

bash

Копировать

`curl -X POST "http://localhost:8000/invalidate?session_id=42" -H "X-API-Key: <Ваш API-ключ>"`

**Пример ответа (JSON):**

json

Копировать

`{     "status": "invalidated",     "session_id": 42 }`

Ответ означает, что сессия помечена как "невыдаваемая". Теперь она не будет предоставляться методом `/session` до тех пор, пока её состояние не будет вручную изменено (например, администратор может снять флаг Flood Wait напрямую в базе данных или переразметить файл сессии).

**Возможные коды ответа:**

- **200 OK** – сессия успешно инвалидирована (либо уже была в таком состоянии).
- **401/403** – отсутствие или неправильный API-ключ (см. выше).
- **422 Unprocessable Entity** – отсутствует параметр `session_id` или он некорректного типа.

## POST `/sync` – Синхронизировать сессии

**Описание:** Выполняет ручную синхронизацию записей о сессиях в базе данных с фактическими файлами сессий на диске. В обычной ситуации сервис сам регулярно (ежечасно) синхронизируется в фоновом режиме. Однако если вы только что добавили новые файлы сессий или удалили некоторые из директории, вы можете вызвать этот эндпоинт, чтобы изменения сразу отразились в базе.

При вызове `/sync` сервис сканирует указанную директорию с файлами `.session` и сравнивает со списком в базе данных:

- Новые файлы сессий будут добавлены в базу (и станут доступны для выдачи).
- Отсутствующие (удалённые) файлы сессий будут убраны из базы данных.
- Сессии, которые есть и там и там, останутся без изменений.  
    Кроме того, при добавлении новых записей им могут назначаться некоторые стандартные параметры (например, прокси-сервер по умолчанию, если предусмотрено – в данном проекте для новых сессий задаётся заранее заданный прокси).

**Тело запроса:** отсутствует (достаточно самого вызова метода). Нужно только присутствие корректного API-ключа.

**Пример запроса (cURL):**

bash

Копировать

`curl -X POST "http://localhost:8000/sync" -H "X-API-Key: <Ваш API-ключ>"`

**Пример ответа (JSON):**

json

Копировать

`{     "status": "sync complete",     "details": {         "new_sessions": 2,         "removed_sessions": 1,         "total_sessions": 10     } }`

В этом примере сервис обнаружил 2 новых сессионных файла, добавил их в базу (`"new_sessions": 2`), удалил 1 запись о сессии, которой больше нет на диске (`"removed_sessions": 1`), и в итоге общее число сессий стало 10. Поле `total_sessions` отражает текущее количество сессий после синхронизации.

**Возможные коды ответа:**

- **200 OK** – синхронизация выполнена, возвращена сводная информация о результатах (как выше).
- **401/403** – проблемы с API-ключом (не указан или неверен).
- **500 Internal Server Error** – при возникновении непредвиденной ошибки (например, проблемы с доступом к диску или БД) сервис может вернуть ошибку сервера. Подробности можно будет найти в логах сервиса.


